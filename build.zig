//! Boost Software License - Version 1.0 - August 17th, 2003
//
//! Permission is hereby granted, free of charge, to any person or organization
//! obtaining a copy of the software and accompanying documentation covered by
//! this license (the "Software") to use, reproduce, display, distribute,
//! execute, and transmit the Software, and to prepare derivative works of the
//! Software, and to permit third-parties to whom the Software is furnished to
//! do so, all subject to the following:
//
//! The copyright notices in the Software and this entire statement, including
//! the above license grant, this restriction and the following disclaimer,
//! must be included in all copies of the Software, in whole or in part, and
//! all derivative works of the Software, unless such copies or derivative
//! works are solely in the form of machine-executable object code generated by
//! a source language processor.

const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});
    const fmt = b.option(bool, "use_fmt", "Build with fmt logger") orelse true;
    buildExe(b, .{
        .filepath = "examples/basic.cpp",
        .target = target,
        .optimize = optimize,
        .use_fmt = fmt,
    });
    buildExe(b, .{
        .filepath = "examples/two_phase.cpp",
        .target = target,
        .optimize = optimize,
        .use_fmt = fmt,
    });
    buildExe(b, .{
        .filepath = "examples/two_phase_many.cpp",
        .target = target,
        .optimize = optimize,
        .use_fmt = fmt,
    });
}

fn buildExe(b: *std.Build, info: BuildInfo) void {
    const exe = b.addExecutable(.{
        .name = info.filename(),
        .target = info.target,
        .optimize = info.optimize,
    });

    // Pre-Building
    exe.addIncludePath(Path.relative("include"));
    exe.addCSourceFile(.{ .file = Path.relative(info.filepath), .flags = &.{
        "-Wall",
        "-Wextra",
        "-Werror",
        "-Wpedantic",
        "-Wshadow",
        "-fexperimental-library",
        "-std=c++20",
    } });

    // Dependencies

    // fmt
    const libfmt_dep = b.dependency("fmt", .{
        .target = info.target,
        .optimize = info.optimize,
    });
    const libfmt = libfmt_dep.artifact("fmt");

    // tigerbeetle
    // const libtb_dep = b.dependency("tigerbeetle", .{
    //     .target = info.target,
    //     .optimize = info.optimize,
    // });
    // const libtb = libtb_dep.artifact("tigerbeetle");

    exe.addIncludePath(Path.relative("build/_deps/tb-src/src/clients/c/lib/include"));
    const arch: []const u8 = switch (info.target.getCpuArch()) {
        .aarch64 => "aarch64",
        else => "x86_64",
    };
    const abi: []const u8 = switch (info.target.getAbi()) {
        .gnu => "gnu",
        else => "musl",
    };
    const os: []const u8 = switch (info.target.getOsTag()) {
        .windows => "windows",
        .macos => "macos",
        else => b.fmt("linux-{s}", .{abi}),
    };

    // Linking libraries
    exe.addLibraryPath(Path.relative(b.fmt("build/_deps/tb-src/src/clients/c/lib/{s}-{s}", .{ arch, os })));
    exe.linkSystemLibraryName("tb_client");
    if (info.target.isWindows())
        exe.linkSystemLibrary("ws2_32");
    if (info.use_fmt) {
        exe.defineCMacro("USE_FMT", null);
        for (libfmt.include_dirs.items) |include| {
            exe.include_dirs.append(include) catch @panic("Unavailable include_dirs");
        }
        exe.linkLibrary(libfmt);
    }

    // exe.linkLibrary(libtb);
    exe.linkLibCpp(); // static-linking llvm-libcxx/abi + linking OS-libc

    // Post-Building
    b.installArtifact(exe); // get copy binaries from: zig-cache/ to zig-out/

    // Run executable file
    const run_cmd = b.addRunArtifact(exe);
    run_cmd.step.dependOn(b.getInstallStep());

    if (b.args) |args| {
        run_cmd.addArgs(args);
    }
    const run_step = b.step(info.filename(), b.fmt("Run the {s} app", .{info.filename()}));
    run_step.dependOn(&run_cmd.step);
}

const BuildInfo = struct {
    filepath: []const u8,
    target: std.zig.CrossTarget,
    optimize: std.builtin.OptimizeMode,
    use_fmt: bool,

    fn filename(self: BuildInfo) []const u8 {
        var split = std.mem.split(u8, std.fs.path.basename(self.filepath), ".");
        return split.first();
    }
};

const Path = std.Build.LazyPath;
