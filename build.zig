//! Boost Software License - Version 1.0 - August 17th, 2003
//
//! Permission is hereby granted, free of charge, to any person or organization
//! obtaining a copy of the software and accompanying documentation covered by
//! this license (the "Software") to use, reproduce, display, distribute,
//! execute, and transmit the Software, and to prepare derivative works of the
//! Software, and to permit third-parties to whom the Software is furnished to
//! do so, all subject to the following:
//
//! The copyright notices in the Software and this entire statement, including
//! the above license grant, this restriction and the following disclaimer,
//! must be included in all copies of the Software, in whole or in part, and
//! all derivative works of the Software, unless such copies or derivative
//! works are solely in the form of machine-executable object code generated by
//! a source language processor.

const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});
    const fmt = b.option(bool, "use_fmt", "Build with fmt logger") orelse true;

    inline for (&.{ "examples/basic.cpp", "examples/two_phase.cpp", "examples/two_phase_many.cpp" }) |filename| {
        buildExe(b, .{
            .filepath = filename,
            .target = target,
            .optimize = optimize,
            .use_fmt = fmt,
        });
    }
}

fn buildExe(b: *std.Build, info: BuildInfo) void {
    const exe = b.addExecutable(.{
        .name = info.filename(),
        .target = info.target,
        .optimize = info.optimize,
    });

    // Pre-Building
    exe.addIncludePath(b.path("include"));
    exe.addCSourceFile(.{
        .file = b.path(info.filepath),
        .flags = &.{
            "-Wall",
            "-Wextra",
            "-Werror",
            "-Wpedantic",
            "-Wshadow",
            "-fexperimental-library",
            "-std=c++20",
        },
    });

    // Dependencies

    // fmt
    const libfmt_dep = b.dependency("fmt", .{
        .target = info.target,
        .optimize = info.optimize,
    });
    const libfmt = libfmt_dep.artifact("fmt");

    // tigerbeetle
    // const libtb_dep = b.dependency("tigerbeetle", .{
    //     .target = info.target,
    //     .optimize = info.optimize,
    // });
    // const libtb = libtb_dep.artifact("tigerbeetle");

    exe.addIncludePath(b.path("build/_deps/tb-src/src/clients/c/lib/include"));
    const arch: []const u8 = switch (exe.rootModuleTarget().cpu.arch) {
        .aarch64 => "aarch64",
        else => "x86_64",
    };
    const abi: []const u8 = switch (exe.rootModuleTarget().abi) {
        .gnu => "gnu.2.27",
        else => "musl",
    };
    const os: []const u8 = switch (exe.rootModuleTarget().os.tag) {
        .windows => "windows",
        .macos => "macos",
        else => b.fmt("linux-{s}", .{abi}),
    };

    // Linking libraries
    exe.addLibraryPath(b.path(b.fmt("build/_deps/tb-src/src/clients/c/lib/{s}-{s}", .{ arch, os })));
    exe.linkSystemLibrary2("tb_client", .{
        .use_pkg_config = .no,
    });
    if (exe.rootModuleTarget().os.tag == .windows)
        exe.linkSystemLibrary("ws2_32");
    if (info.use_fmt) {
        exe.defineCMacro("USE_FMT", null);
        for (libfmt.root_module.include_dirs.items) |include| {
            exe.root_module.include_dirs.append(b.allocator, include) catch @panic("Unavailable include_dirs");
        }
        exe.linkLibrary(libfmt);
    }

    // exe.linkLibrary(libtb);
    exe.linkLibCpp(); // static-linking llvm-libcxx/abi + linking OS-libc

    // Post-Building
    b.installArtifact(exe); // get copy binaries from: zig-cache/ to zig-out/

    // Run executable file
    const run_cmd = b.addRunArtifact(exe);
    run_cmd.step.dependOn(b.getInstallStep());

    if (b.args) |args| {
        run_cmd.addArgs(args);
    }
    const run_step = b.step(info.filename(), b.fmt("Run the {s} app", .{info.filename()}));
    run_step.dependOn(&run_cmd.step);
}

const BuildInfo = struct {
    filepath: []const u8,
    target: std.Build.ResolvedTarget,
    optimize: std.builtin.OptimizeMode,
    use_fmt: bool,

    fn filename(self: BuildInfo) []const u8 {
        var split = std.mem.splitSequence(u8, std.fs.path.basename(self.filepath), ".");
        return split.first();
    }
};
